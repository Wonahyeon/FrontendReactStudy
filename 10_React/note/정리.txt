#0523
[리액트 시작]
- 새로운 package 만들었을 때(또는 협업 시)
  git pull -> npm install
* npm 사용 시 경로 중요 (package.json 파일 있어야 됨)
- npm start

[JSX 문법]
- 태그 열었으면 무조건 닫아야 함
- 여러 개 태그 사용 시 하나의 부모 태그 필요
  <></> : React.Fragment
- JSX내 자바스크립트 변수나 함수 사용 시
  {} 필요



#0524
[JSX 문법]
- 인라인 스타일 객체 형태로 작성
- 속성명 카멜 케이스 사용
  예: backgroundColor
- css 파일 연결
  import '파일 경로';
- class값 설정 시 class="" 아닌
  className=""
- JSX내 주석 사용 방법 ctrl + /
  {/* 이런 형태 */}

[컴포넌트1]
- 파일명 파스칼 케이스 사용
  예: Book
- 리액트 '함수' 컴포넌트
- 리액트 엘리먼트를 반환
- 완성 후 내보내기!!! -> 다른 곳에서 사용하려면 꼭!
  export default 컴포넌트명;
- 화면 띄우기
  index.js에 컴포넌트 렌더링

[엘리먼트]
- DOM 엘리먼트 가상 표현
- 불변성 = 변하지 않는 성질
  한 번 생성된 엘리먼트 변하지 않음
  생성 후 자식이나 속성 바꿀 수 없음
- 변경하는 것이 아니라 새로운 엘리먼트 생성
- 새로운 엘리먼트를 기존 엘리먼트와 바꿈
- UI 업데이트
  새로운 엘리먼트 생성 후 root.render()로 전달

[컴포넌트2]
- 모든 페이지가 컴포넌트로 구성, 하나의 컴포넌트는 또 다른 여러 컴포넌트들의 조합으로 만들 수 있음
- 반복되는 부분을 컴포넌트로 만들어 재사용
  => 재사용 가능하도록 얼마나 컴포넌트를 잘 쪼개고 잘 조립하는지가 중요
- 자바스크립트 함수와 유사
  props를 입력으로 받아서 그에 맞는 React 엘리먼트를 생성하여 반환

[props] 
- 키-값 쌍의 형태로 컴포넌트에 전달 가능
  => 객체
- 정수, 변수, 다른 컴포넌트 등 값을 넣을 때 {}
  문자열은 {} 생략 가능
- props로 다른 컴포넌트를 넘기는 것도 가능
- 다른 컴포넌트 넘기면서 props 넣을 수 있음
  예: header={<Header title="타이틀"/>}
- read-only 읽기 전용
  => 변경 불가
- 변경하려면 전달하는 데이터를 변경

[컴포넌트 만들기]
- 클래스 컴포넌트
  React 초기 버전 주로 사용
  사용 불편 -> 함수 컴포넌트 + 훅(Hook)으로 대체
- 함수 컴포넌트(권장)
  자바스크립트 함수 형태로 된 컴포넌트
  코드 간결 사용 용이
- 컴포넌트명 항상 대문자로 시작!!
  React는 소문자로 시작하는 컴포넌트를 HTML DOM Tag로 인식

#0525
[State]
- 클래스 컴포넌트
- React 컴포넌트 상태
  => 변경 가능한 데이터
- 컴포넌트에서 보여줘야 하는 내용이 사용자 인터랙션에 따라 동적으로 바뀌어야 할 때 사용
- 개발자가 직접 정의해서 사용
- 렌더링과 관련된 값만 state에 포함시켜야 함
  -> 불필요한 재렌더링 발생으로 성능 저하
- 직접적으로 변경하면 안됨
  -> 값은 변경되지만 재렌더링(화면 업데이트) 안됨
- 클래스 컴포넌트(사용x)
  - 생성자(constructor)에서 state 정의
  - setState() 함수를 통해 state 업데이트
- 함수 컴포넌트
  - useState() Hook을 사용하여 각각의 state 정의
  - 각 state별로 주어지는 set함수 사용하여 state 값 변경

[Lifecycle]
- React 컴포넌트 생명주기
- 컴포넌트는 계속 존재하는 것이 아니라 데이터 흐름에 따라 생성되고 업데이트 되다가 사라지는 과정을 겪음

<Mounting - 마운트(출생)>
- 컴포넌트가 생성될 때
- constructor() 호출
- render() 호출
- componentDidMount() 호출

<Updating - 업데이트(인생)>
- 컴포넌트가 업데이트 될 때
  -> 바뀐 부분에 대한 재렌더링이 일어날 때
- 업데이트가 일어나는 조건
  New props: 컴포넌트 props 변경
  setState(): state 변경
  forceUpdate(): 강제 업데이트
- render() 호출
- componentDidUpdate() 호출

<Unmounting - 언마운트(사망)>
- 컴포넌트가 사라질 때
  현재 컴포넌트 더 이상 화면에 표시하지 않게 될 때
- 언마운트 직전에 componentWillUnmount() 호출

[State 실습 - 클래스 컴포넌트 사용]
- 리액트 컴포넌트 상속받은 클래스 생성
  예: class 클래스명 extends React.component
    * import React  from "react";
- 매개변수가 props인 constructor() 함수
  - 부모 클래스에 props 값 전달
    super(props);
  - state 생성
    -> 변경 시: this.setState();

- 컴포넌트가 생성될 때 호출되는 메소드
  componentDidMount()
- 컴포넌트가 마운트 된 이후 호출
  componentDidMount()
- 컴포넌트가 업데이트 된 이후 호출
  componentDidUpdate()
- 컴포넌트가 언마운트 되기 전 호출
  componentWillUnmount()

- render() 함수 호출
  return 값은 엘리먼트(객체)로 반환

TODO 크롬 웹 스토어 - react developer tools

[Hook]
- 함수 컴포넌트!
- class 없이 react 기능 사용
  -> useState(), useEffect()
- react state와 생명주기 기능
- 모두 use로 시작함

[useState]
- 가장 대포적이고 많이 사용되는 Hook
- state를 생성하고 변경하기 위한 Hook
- 함수 컴포넌트에서 기본적으로 state 제공하지 않음
  => useState() 사용
- 사용법
  - const [변수명, set함수명] = useState(초기값);
    예: const [count, setCount] = useState(0);
    => useState 배열, 변수 배열 구조 분해 할당
  - 변수 각각에 대해 set함수가 따로 존재

[Quiz - 글자색 바꾸기]
- 인라인 스타일 값 !객체!
  style={{color: }}

[Quiz - 버튼 내용 바꾸기(2가지 방법)]
1. 버튼 내용 변수
  setText('마감')
  <button>{text}</button>
2. 삼항 연산자 사용 -> jsx if문 사용 못함
  setText(true)
  {test? '마감':'신청'}

*
- set함수 비동기 함수
- 리액트는 set함수 동시에 여러 개
- 마지막 set함수, 나머지 merge
=> state와 상관없이 새로운 값을 넣는 것이 아니면 콜백 형태로 쓸 것을 권장, 이때 콜백 함수의 첫번째 매개변수로 이전 state 받아와서 처리

[useEffect]
- 사이드 이펙트를 수행하기 위한 Hook
  - 함수의 핵심 기능과 상관없는 부가 기능
    예: 서버에서 데이터 받아오는 작업
  - 다른 컴포넌트에 영향을 미칠 수 있으며 렌더링이 끝난 이후에 실행되어야 하는 작업들
- TODO
- 클래스 컴포넌트의 생명주기 메서드들과 동일한 기능 수행 가능
  componentDidMount()
  componentDidUpdate()
  componentWillUnmount()
  3개를 하나로 통합해서 제공

- 사용법
  매개변수: 콜백함수, 의존성 배열
  - 두 번째 인자값 안 넘겨주면
    처음 마운트 될 때 + 매번 업데이트 될 때마다 실행
  - 두 번째 인자값 빈 배열로 넘겨주면
    처음 마운트 될 때만 실행
  - 두 번째 인자값에 state로 넘겨주면
    처음 마운트 될 때 + 해당 state 값이 바뀔때만 실행됨
  - 렌더링 끝난 직후 실행

[정리]
useEffect()를 쓰는 경우?
- useEffect() 안에 콜백 함수는 HTML 렌더링 후에 동작함 => 연산이 오래 걸리는 작업들을 넣으면 좋음
- 아니면 주로 처음 렌더링 시 해줘야 하는 초기 작업들
1) 에러가 떠서 페이지를 백 시켜야 할 때
2) 마운트 됐을 때 그 페이지를 이용할 수 있는 사용자인지 권한 체크
3) 타이머를 동작 시킬 때
4) 주로 데이터 패치 관련 작업을 많이 넣음 (주로 사용)